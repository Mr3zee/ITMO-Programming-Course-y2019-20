### Домашнее задание 10. Функциональные выражения на Clojure

1. Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений. ✅
   1. Пример описания выражения `2x-3`:
      ```
      (def expr
        (subtract
          (multiply
            (constant 2)
            (variable "x"))
          (constant 3)))             
      ```

   2. Выражение должно быть функцией, возвращающей значение выражение при подстановке элементов, заданных отображением. Например, `(expr {"x" 2})` должно быть равно 1.

2. Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например, 
   
   `(parseFunction "(- (* 2 x) 3)")`
   
   должно быть эквивалентно`expr`. ✅
   
3. **Сложный вариант.** Функции `add`, `subtract`, `multiply` и `divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`. ✅

4. При выполнении задания следует обратить внимание на:

   - Выделение общего кода для операций.

**Модификации:**

- _PwLg_. Дополнительно реализовать поддержку: ✅
  - бинарных операций:
    - `pw` – возведение в степень, `(pow 2 3)` равно 8;
    - `lg` – логарифм абсолютной величины по основанию абсолютной величины, `(lg -8 -2)` равно 3.
- _ExpLn_. Дополнительно реализовать поддержку: ✅
  - унарных операций:
    - `exp` – экспонента, `(exp 8)` примерно равно 2981;
    - `ln` – натуральный логарифм абсолютной величины, `(ln -2981)` примерно равно 8.
- _MinMax_. Дополнительно реализовать поддержку: ✅
  - операций произвольного числа аргументов:
    - `min` – минимум, `(min 1 2 6)` равно 1;
    - `max` – максимум, `(min 1 2 6)` равно 6;
- _MedAvg_. Дополнительно реализовать поддержку: ✅
  - операций произвольного числа аргументов:
    - `med` – медиана, `(med 1 2 6)` равно 2;
    - `avg` – среднее, `(avg 1 2 6)` равно 3;

### Домашнее задание 11. Объектные выражения на Clojure

1. Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной. ✅
   1. Пример описания выражения `2x-3`:
      ```
      (def expr
        (Subtract
          (Multiply
            (Constant 2)
            (Variable "x"))
          (Const 3)))
      ```
   2. Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно 1. ✅

   3. Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме. ✅

   4. Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,  
        
   `(parseObject "(- (* 2 x) 3)")`
        
   должно быть эквивалентно `expr`. ✅
        
5. Функция`(diff expression "variable")` должна возвращать выражение, представляющее производную исходного выражения по заданной переменной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Const 2) (Const 0))`и 
      ```
      (Subtract
        (Add
          (Multiply (Const 0) (Variable "x"))
          (Multiply (Const 2) (Const 1)))
        (Const 0))       
      ```
      так же будут считаться правильным ответом. ✅
   
2. **Сложный вариант.** Конструкторы `Add`, `Subtract`, `Multiply` и `Divide` должны принимать произвольное число аргументов. Разборщик так же должен допускать произвольное число аргументов для `+`, `-`, `*`, `/`. ✅

3. При выполнении задания можно использовать любой способ преставления объектов.

**Модификации:**

*SumAvg*. Дополнительно реализовать поддержку: ✅

- операций произвольного числа аргументов:
  - `Sum` (`sum`) – сумма, `(sum 1 2 3)` равно 6;
  - `Avg` (`avg`) – арифметическое среднее, `(avg 1 2 3)` равно 2;

### Домашнее задание 12. Комбинаторные парсеры

1. **Простой вариант.** ✅
   Реализуйте функцию`(parseObjectSuffix "expression")`, разбирающую выражения, записанные в суффиксной форме, и функцию`toStringSuffix`, возвращающую строковое представление выражения в этой форме. Например, 
   
   `(toStringSuffix (parseObjectSuffix "( ( 2 x * ) 3 - )"))` 
   
   должно возвращать `((2 x *) 3 -)`.
   
2. **Сложный вариант. **✅
   Реализуйте функцию `(parseObjectInfix "expression")`, разбирающую выражения, записанные в инфиксной форме, и функцию`toStringInfix`, возвращающую строковое представление выражения в этой форме. Например, 
   
   `(toStringInfix (parseObjectInfix "2 * x - 3"))` 
   
   должно возвращать `((2 * x) - 3)`.
   
3. **Бонусный вариант.**  ❌

   Добавьте в библиотеку комбинаторов возможность обработки ошибок и продемонстрируйте ее использование в вашем парсере.

4. Функции разбора должны базироваться на библиотеке комбинаторов, разработанной на лекции.

**Модификации:**

*Bitwise*. Дополнительно реализовать поддержку: ✅

- Побитовых операций
  - `And` (`&`) – и: `5 & 6` равно 4
  - `Or` (`|`) - или: `5 & 6` равно 7
  - `Xor` (`^`) - исключающее или: `5 ^ 6` примерно равно 1.66881E-308
  - для реализации операций используйте [doubleToLongBits](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#doubleToLongBits(double)) и [longBitsToDouble](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Double.html#longBitsToDouble(long))
  - операции по увеличению приоритета: `^`, `|`, `&`, `+` и `-`, `*` и `/`